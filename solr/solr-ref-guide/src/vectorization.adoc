= Vectorization
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

This section of the user guide explores techniques
for retrieving data from Solr and transforming the result
sets into vectors and matrices that can be operated on by
math expressions.

== streams

Streaming Expressions have a wide range of stream sources that can be used to
retrieve data from Solr Cloud collections. Math expressions can be used
to vectorize the data and analyze the

Some key stream sources include:

=== `random`

Random sampling is widely used in statistics, probability and machine learning.
The `random` Streaming Expression a random sample of search results that match a
specific query.

=== `timeseries`

Time series analysis is one of the primary data science use cases. The `timeseries`
expression provide fast distributed time series aggregations, which can be
analyzed with math expressions.

=== `knnSearch`

The K-nearest algorithm is one of core machine learning algorithm. The `knnSearch`
function is specialized knn function finds the k-nearest neighbors of a document in
a distributed document collection. Once the numbers are retrieved they can be vectorized
and operated on by machine learning and text mining algorithms.

=== `sql`

SQL is the primary query language used by data scientist. The `sql` function allows
for data retrieval using subset SQL that supports both full text search and
fast distributed aggregations. The result sets can then be vectorized and operated
on by math expressions.

=== `topic`

Messaging provides an important foundation for large scale computing. The `topic` function
provides publish/subscribe messaging by treating an entire Solr Cloud collection as message
queue. Topics are extremely powerful because the allow for subscriptions that match any
Solr query. As new documents are published that match the topic query they can be
operated on by math expressions, providing powering AI alerting capabilities.

=== `nodes`

Graph traversal is primary tool for recommendation engines and also is key
tool in machine learning. The `nodes` function provides fast, distributed, breadth
first graph traversal for documents in a Solr Cloud collection. The node sets collected
by graph traversal can be operated on by statistical and machine learning math
expressions to gain more insight into the graph and provide better recommendations.

=== `search`

Ranked search results are a powerful tool for finding the most relevant
documents from a large document corpus. The `search` expression
returns the top N ranked search results that match any
Solr query including geo-spatial queries. The smaller set of relevant
documents can then be explored with statistical, machine learning and
text mining math expressions to gather insights about the data set.

== Assigning Streams to Variables

The output of any streaming expresssion can be set to a variable.
Below is very simple example using the `random` function to fetch
three random samples from collection1. The random samples are returned
as *tuples*, which are name/value pairs.


Here is a very simple example:

[source,text]
----
let(a=random(collection1, q="*:*", rows="3", fl="price_f"))
----

When this expression is sent to the /stream handler it responds with:

[source,json]
----
{
  "result-set": {
    "docs": [
      {
        "a": [
          {
            "price_f": 0.7927976
          },
          {
            "price_f": 0.060795486
          },
          {
            "price_f": 0.55128294
          }
        ]
      },
      {
        "EOF": true,
        "RESPONSE_TIME": 11
      }
    ]
  }
}
----

== Creating a Vector with the *col* Function

The `col` function iterates throw a list of tuples and copies the values
from a specific column into an *array*.

The output of the `col` function is an numeric array that can be set to a
variable and operated on by math expressions.

Below is an example of the `col` function:

[source,text]
----
let(a=random(collection1, q="*:*", rows="3", fl="price_f"),
    b=col(a, price_f))
----

[source,json]
----
{
  "result-set": {
    "docs": [
      {
        "b": [
          0.42105234,
          0.85237443,
          0.7566981
        ]
      },
      {
        "EOF": true,
        "RESPONSE_TIME": 9
      }
    ]
  }
}
----

== Applying Math Expressions to the Vector

[source,text]
----
let(a=random(collection1, q="*:*", rows="15000", fl="price_f"),
    b=col(a, price_f),
    c=mean(b))
----

[source,json]
----
{
  "result-set": {
    "docs": [
      {
        "c": 0.5016035594638814
      },
      {
        "EOF": true,
        "RESPONSE_TIME": 306
      }
    ]
  }
}
----
