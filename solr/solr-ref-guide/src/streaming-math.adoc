= Streaming Math
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

This section of the user guide describes how to apply math expression to streams
of data. There are two general approaches to this: performing math on tuples as
part of a streaming pipeline, or reading streams of tuples into variables in
memory and then operating on the variables. Both of these techniques will be
described in the examples below.

== Streams

Streaming Expressions has a wide range of stream sources and
decorators that can be used in conjuction with math expressions.

Some key stream sources include:

* `search`: Top N results matching a search query including geo-spatial
* `knnSearch`: Top N results most similar to a document in the index
* `sql`: A subs-set of SQL that supports full text search and aggregations
* `timeseries`: Fast times series aggregations
* `topic`: Publish/Subscribe message queues that provide one-time deliver of documents that match a query.
* `random`: Fast random sampling of results matching a query
* `nodes`: Distributed breadth-first graph traversal and aggregations
* `facet`: Faceted aggregations

== Streaming Scalar Math

Math expressions can be applied to each tuple in a stream through the
`select` stream decorator. The `select` function wraps a stream of tuples
and selects fields to include in each tuple. The `select` function
can also use math expressions to compute new values and add them to the
outgoing tuples.

In the example below the `select` expression is wrapping a search
expression. The `select` function is selecting the *price_f* field
and computing a new field called *newPrice* using the `mult` math
expression.

The first parameter of the `mult` expression is the *price_f* field.
The second parameter is the scalar value 10. This multiplies the value
of the *price_f* field in each tuple by 10.

[source,text]
----
select(search(collection2, q="*:*", fl="price_f", sort="price_f desc", rows="3"),
       price_f,
       mult(price_f, 10) as newPrice)
----

When this expression is sent to the /stream handler it responds with:

[source,json]
----
{
  "result-set": {
    "docs": [
      {
        "price_f": 0.99999994,
        "newPrice": 9.9999994
      },
      {
        "price_f": 0.99999994,
        "newPrice": 9.9999994
      },
      {
        "price_f": 0.9999992,
        "newPrice": 9.999992
      },
      {
        "EOF": true,
        "RESPONSE_TIME": 3
      }
    ]
  }
}
----

== Streaming Vector Math

The same technique can be used to perform vector math on multivalue
numeric fields in tuples.

[source,text]
----
select(search(collection2, q="*:*", fl="price_f", sort="price_f desc", rows="3"),
       price_f,
       mult(price_f, 10) as newPrice)
----

When this expression is sent to the /stream handler it responds with:

[source,json]
----
{
  "result-set": {
    "docs": [
      {
        "price_f": 0.99999994,
        "newPrice": 9.9999994
      },
      {
        "price_f": 0.99999994,
        "newPrice": 9.9999994
      },
      {
        "price_f": 0.9999992,
        "newPrice": 9.999992
      },
      {
        "EOF": true,
        "RESPONSE_TIME": 3
      }
    ]
  }
}
----